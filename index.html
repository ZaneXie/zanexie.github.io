<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Zongjun Xie&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Web开发">
<meta property="og:type" content="website">
<meta property="og:title" content="Zongjun Xie's Blog">
<meta property="og:url" content="http://www.xiezj.net/index.html">
<meta property="og:site_name" content="Zongjun Xie's Blog">
<meta property="og:description" content="Web开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zongjun Xie's Blog">
<meta name="twitter:description" content="Web开发">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/scrollUp/image.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">Zongjun Xie's Blog</div>
      
        <div id="subtitle">谢宗钧的Blog</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">Zongjun Xie&#39;s Blog</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="www.xiezj.net">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main">
  

    
    <article id="post-Github Pages &amp; hexo安装与使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/24/Github Pages & hexo安装与使用/" class="article-date">
  <time datetime="2017-01-24T08:09:03.000Z" itemprop="datePublished">2017-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/24/Github Pages & hexo安装与使用/">Github Pages &amp; hexo 的安装与使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Github Pages 提供了免费的静态文件服务，用来搭建简单的个人网站很是方便。下面介绍一下如何使用Github Pages制作个人博客。</p>
<p>由于Github Pages只能提供静态文件服务，因此不能使用类似wordpress的博客系统。一番搜索之后找到了<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo</a>，一个使用nodejs来生成静态文件的博客系统。</p>
<h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>在github上创建一个新的repository，名字叫username.github.io，比如我的是<a href="https://github.com/zanexie/zanexie.github.io" target="_blank" rel="external">https://github.com/zanexie/zanexie.github.io</a>。接下来clone这个repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/username/username.github.io</div></pre></td></tr></table></figure>
<p>创建一个简单的hello world页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd username.github.io</div><div class="line"></div><div class="line">echo &quot;Hello World&quot; &gt; index.html</div></pre></td></tr></table></figure></p>
<p>将修改push到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git add --all</div><div class="line"></div><div class="line">git commit -m &quot;Initial commit&quot;</div><div class="line"></div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>然后打开浏览器，浏览<a href="https://username.github.io" target="_blank" rel="external">https://username.github.io</a>，一切正常将能看到hello world的页面。</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Github Pages测试正常之后，开始安装hexo。</p>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>hexo依赖<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>，先到官网下载安装。windows系统在<a href="https://nodejs.org" target="_blank" rel="external">官网</a>下载安装包安装，mac和linux可以下载安装包，可以使用包管理器安装，具体的方法可以搜索一下。</p>
<p>安装好Nodejs后，在命令行执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm --version</div></pre></td></tr></table></figure>
<p>能显示版本号表示安装成功，如果提示npm not found，则是安装失败了（或者npm不在path里），重试直到npm安装成功。</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>国内的同学如果上面命令执行慢，先换国内的源，再执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set registry https://registry.npm.taobao.org</div><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>
<h4 id="创建一个blog"><a href="#创建一个blog" class="headerlink" title="创建一个blog"></a>创建一个blog</h4><p>在刚才创建的username.github.io目录里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init src</div><div class="line">cd src</div></pre></td></tr></table></figure></p>
<p>开启hexo服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p>
<p>新开一个终端，创建文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd path/to/username.github.io （修改为自己的路径）</div><div class="line">hexo new &quot;hello world!</div></pre></td></tr></table></figure></p>
<p>到src/sources/_posts里找到hello world.md，写点文字。打开浏览器访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>（默认端口4000，执行hexo server时会有提示）。这时就能看到刚才创建的hello world了！</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>hexo配置文件在src/_config.yml，title、subtitle、description，url等根据自己的情况修改。public_dir默认是public，修改成../，接下来生成网站！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate</div></pre></td></tr></table></figure>
<p>成功之后，会在username.github.io目录里生成网站的静态文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd ..</div><div class="line">git add --all</div><div class="line">git commit -m &quot;first blog&quot;</div><div class="line">git push</div></pre></td></tr></table></figure>
<p>Github Pages有缓存，稍等片刻，再访问<a href="https://username.github.io" target="_blank" rel="external">https://username.github.io</a>便能看到新的文章了。</p>
<h4 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h4><h5 id="分离源码与静态页面"><a href="#分离源码与静态页面" class="headerlink" title="分离源码与静态页面"></a>分离源码与静态页面</h5><p>上面的步骤里，把文章源码(/src)和静态网页(/)放到了一起，这样可以使用一个repository同时保存源码与静态网页。也可以将文章源码新建一个repository单独保存，前面创建hexo项目的代码稍作修改。</p>
<ul>
<li><p>创建</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ..</div><div class="line">hexo init myblog</div><div class="line">cd myblog</div></pre></td></tr></table></figure>
</li>
<li><p>不用修改public_dir的值（使用默认的public），生成完成后将文件拷贝到username.github.io里并push到github，或者安装hexo-depoloy-git</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p>修改配置_config.yml</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>repo</td>
<td>GitHub/Bitbucket/Coding/GitLab repository URL</td>
</tr>
<tr>
<td>branch</td>
<td>分支名. 如果使用GitHub或者GitCafe则不用配置，部署器会自行检测</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息(默认值为Site updated: 当前时间)</td>
</tr>
</tbody>
</table>
<ul>
<li>部署  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="实用的插件"><a href="#实用的插件" class="headerlink" title="实用的插件"></a>实用的插件</h5><p>安装插件时，注意要在源码目录(/src)里，安装后重启hexo server</p>
<ul>
<li>修改md文件后自动刷新浏览器，免去手动刷新网页的烦恼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save hexo-browsersync</div></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果重新克隆了源码，记得安装一次依赖，在src目录中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.xiezj.net/2017/01/24/Github Pages & hexo安装与使用/" data-id="ciybblkl40000ycnqsrewioka" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-PHP7-opcode查看器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/PHP7-opcode查看器/" class="article-date">
  <time datetime="2015-12-18T11:12:50.000Z" itemprop="datePublished">2015-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/PHP7-opcode查看器/">PHP7 opcode查看器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果要进一步理解PHP的运行原理，就涉及到了PHP的opcode：opcode是一种中间代码，和Java的ByteCode或者.NET的MSL类似。</p>
<p>从底层来看，PHP执行的基本原理是： 读取php文件 –&gt; 编译为中间代码opcode –&gt; 执行。这个模式在PHP5与PHP7之间并没有变化，我就不在这班门弄斧了，有兴趣的同学可以看鸟哥的深入理解PHP原理之Opcodes和Sara Golemon大师的Understanding Opcodes。</p>
<p>有了上面的基础，好奇的同学肯定对PHP代码会编译成什么样的Opcode感兴趣了，怎么能看到opcode呢？首先，可以通过调试源码的方式看到。调试的方法在PHP7源码的编译与调试有介绍，将断点打在Zend/zend.c的zend_execute_scripts里，其中的zend_compile_file(file_handle, type)是编译，zend_execute(op_array, retval)是执行（在PHP-7.0.0中为zend.c的1422行和1428行，见php-src/Zend/zend.c），zend_compile_file返回的op_array就是opcode数组了。不过这样看太痛苦了，PHP有一个很好的opcode查看器VLD，通过扩展的方式显示opcode的分析结果，参考作者的说明可以很方便的看到opcode。</p>
<p>vld集成了很多功能，输出的内容也很多，opcode到底是怎么实现的并不容易看懂。为了更直观的理解opcode，我写了一个简单的PHP7扩展opcode查看器。</p>
<p>这是一个简单php扩展，除去PHP扩展必须的代码,只有100多行，应该很容易理解。基本原理是这样：</p>
<p>使用PHP_RINIT_FUNCTION，在Request init的时候将php的zend_compile_file函数替换为自己的opdump_compile_file函数。<br>opdump_compile_file函数调用php的zend_compile_file函数，翻译、存储返回结果op_array后，将op_array返回。<br>PHP7的扩展与PHP5的扩展创建与使用方法相同，可以参考鸟哥的文章用C/C++扩展你的PHP。介绍一下opdump的原理：</p>
<p>zend_compile_file返回一个zend_op_array，定义在zend_compile.h，比较长：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _zend_op_array &#123;</div><div class="line">    <span class="comment">/* Common elements */</span></div><div class="line">    zend_uchar type;</div><div class="line">    zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></div><div class="line">    <span class="keyword">uint32_t</span> fn_flags;</div><div class="line">    zend_string *function_name;</div><div class="line">    zend_class_entry *scope;</div><div class="line">    zend_function *prototype;</div><div class="line">    <span class="keyword">uint32_t</span> num_args;</div><div class="line">    <span class="keyword">uint32_t</span> required_num_args;</div><div class="line">    zend_arg_info *arg_info;</div><div class="line">    <span class="comment">/* END of common elements */</span></div><div class="line"></div><div class="line">    <span class="keyword">uint32_t</span> *refcount;</div><div class="line"></div><div class="line">    <span class="keyword">uint32_t</span> this_var;</div><div class="line"></div><div class="line">    <span class="keyword">uint32_t</span> last;</div><div class="line">    zend_op *opcodes;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> last_var;</div><div class="line">    <span class="keyword">uint32_t</span> T;</div><div class="line">    zend_string **vars;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> last_brk_cont;</div><div class="line">    <span class="keyword">int</span> last_try_catch;</div><div class="line">    zend_brk_cont_element *brk_cont_array;</div><div class="line">    zend_try_catch_element *try_catch_array;</div><div class="line"></div><div class="line">    <span class="comment">/* static variables support */</span></div><div class="line">    HashTable *static_variables;</div><div class="line"></div><div class="line">    zend_string *filename;</div><div class="line">    <span class="keyword">uint32_t</span> line_start;</div><div class="line">    <span class="keyword">uint32_t</span> line_end;</div><div class="line">    zend_string *doc_comment;</div><div class="line">    <span class="keyword">uint32_t</span> early_binding; <span class="comment">/* the linked list of delayed declarations */</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> last_literal;</div><div class="line">    zval *literals;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>  cache_size;</div><div class="line">    <span class="keyword">void</span> **run_time_cache;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *reserved[ZEND_MAX_RESERVED_RESOURCES];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>opcode存放在opcodes数组中，每行是一句code， last是code的行数。每行code是zend_op:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _zend_op &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *handler;</div><div class="line">    znode_op op1;          <span class="comment">//操作数1</span></div><div class="line">    znode_op op2;          <span class="comment">//操作数2</span></div><div class="line">    znode_op result;       <span class="comment">//返回值</span></div><div class="line">    <span class="keyword">uint32_t</span> extended_value;</div><div class="line">    <span class="keyword">uint32_t</span> lineno;       <span class="comment">//行号</span></div><div class="line">    zend_uchar opcode;     <span class="comment">//操作类型</span></div><div class="line">    zend_uchar op1_type;  <span class="comment">//操作数1类型</span></div><div class="line">    zend_uchar op2_type;  <span class="comment">//操作数2类型</span></div><div class="line">    zend_uchar result_type;  <span class="comment">//返回值类型</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中opcode是操作类型，定义在Zend/zend_vm_opcodes.h，op1_type、op2_type、result_type定义在zend_compile.h:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define IS_CONST    (1&lt;&lt;0)</div><div class="line">#define IS_TMP_VAR  (1&lt;&lt;1)</div><div class="line">#define IS_VAR      (1&lt;&lt;2)</div><div class="line">#define IS_UNUSED   (1&lt;&lt;3)  /* Unused variable */</div><div class="line">#define IS_CV       (1&lt;&lt;4)  /* Compiled variable */</div><div class="line"></div><div class="line">#define EXT_TYPE_UNUSED (1&lt;&lt;5)</div></pre></td></tr></table></figure>
<p>使用内置的zend_get_opcode_name显示opcode，再将op1，op2，result稍作处理显示出来。</p>
<p>这样，一个简易的opdump就完成了，代码中将opcode输出到了php文件相同目录下的filename.php.opcodes文件中。测试一个简单的php文件：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$a = <span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">echo</span> $a;</div></pre></td></tr></table></figure>
<p>输出的opcode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ZEND_ASSIGN CV+96   string:hello world  unknown</div><div class="line">ZEND_ECHO   CV+96   unused  unused</div><div class="line">ZEND_RETURN long:1  unused  unused</div></pre></td></tr></table></figure>
<p>CV表示compiled varaible, +96表示偏移量。上面的意思是把string:hello world赋值到CV+96的位置，再对CV+96调用echo，最后返回long:1。</p>
<p>实现：<a href="https://github.com/zanexie/php7-opdump" target="_blank" rel="external">https://github.com/zanexie/php7-opdump</a> </p>
<p>如果要更进一步的了解opcode，可以参考vld的代码。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.xiezj.net/2015/12/18/PHP7-opcode查看器/" data-id="ciyaj57jt0000agnqves9a51e" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-PHP7之HashTable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/PHP7之HashTable/" class="article-date">
  <time datetime="2015-12-09T12:04:16.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/PHP7之HashTable/">PHP7之HashTable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HashTable是PHP内核里十分重要的数据结构，承载着PHP大部分的语法特性，例如：函数表，类的属性、方法等。</p>
<p>为了提高性能，PHP7重新实现了HashTable，相较之前的版本在内存和CPU的使用上均有了很大的提升。<a href="https://nikic.github.io/aboutMe.html" target="_blank" rel="external">Nikic</a>一年前（2014年12月）发布在github.io上的文章<a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html" target="_blank" rel="external">PHP’s new hashtable implementation</a> ，详细解释了新的实现，并说明了为何比之前的实现效率更高。不过文章发布时PHP7还在开发阶段，最终release的时候HashTable做了一些细微的调整，与Nikic的文章略有差别，在下文中会做详细介绍。</p>
<h2 id="PHP5的HashTable"><a href="#PHP5的HashTable" class="headerlink" title="PHP5的HashTable"></a>PHP5的HashTable</h2><p>PHP5的HashTable，为解决Hash冲突使用了链表，大致的实现如下图所示：</p>
<img src="/2015/12/09/PHP7之HashTable/basic_hashtable.svg" alt="basic_hashtable" title="basic_hashtable">
<p>更详细的描述可以在PHP Internals Books的<a href="http://www.phpinternalsbook.com/hashtables/basic_structure.html" target="_blank" rel="external">Basic Structure</a>章节找到。</p>
<h2 id="PHP7的HashTable"><a href="#PHP7的HashTable" class="headerlink" title="PHP7的HashTable"></a>PHP7的HashTable</h2><p>PHP5的HashTable使用链表解决Hash冲突，虽然实现了常数时间的增删查改，但是产生了一些额外的开销，比如：每个Bucket需要单独申请内存（allocation)，不仅耗时而且为存储指针需要额外的空间开销；为实现数组有序而使用的双向链表会占用额外的空间…… 为了提高HashTable的性能，PHP7重新定义了PHP最基础的数据结构zval，并以此重新设计了HashTable。</p>
<h3 id="新的zval"><a href="#新的zval" class="headerlink" title="新的zval"></a>新的zval</h3><p>先来看看新的zend_value，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value &#123;</div><div class="line">    zend_long         lval;                <span class="comment">/* long value */</span></div><div class="line">    <span class="keyword">double</span>            dval;                <span class="comment">/* double value */</span></div><div class="line">    zend_refcounted  *counted;</div><div class="line">    zend_string      *str;</div><div class="line">    zend_array       *arr;</div><div class="line">    zend_object      *obj;</div><div class="line">    zend_resource    *res;</div><div class="line">    zend_reference   *ref;</div><div class="line">    zend_ast_ref     *ast;</div><div class="line">    zval             *zv;</div><div class="line">    <span class="keyword">void</span>             *ptr;</div><div class="line">    zend_class_entry *ce;</div><div class="line">    zend_function    *func;</div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">        <span class="keyword">uint32_t</span> w1;</div><div class="line">        <span class="keyword">uint32_t</span> w2;</div><div class="line">    &#125; ww;</div><div class="line">&#125; zend_value;</div></pre></td></tr></table></figure>
<p>zend_value将简单数值（long和double）嵌入在了zend_value中，其他类型均使用一个指针指向实际的地址。需要注意的是，这是一个union，也就是说这里定义的所有元素共享一块内存，在64位机器上，long、double、指针均是8字节，所以这里一共占用8字节。 接下来就是zval</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _zval_struct &#123;</div><div class="line">    zend_value        value;            <span class="comment">/* value */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            ZEND_ENDIAN_LOHI_4(</div><div class="line">                zend_uchar    type,            <span class="comment">/* active type */</span></div><div class="line">                zend_uchar    type_flags,</div><div class="line">                zend_uchar    const_flags,</div><div class="line">                zend_uchar    reserved)        <span class="comment">/* call info for EX(This) */</span></div><div class="line">        &#125; v;</div><div class="line">        <span class="keyword">uint32_t</span> type_info;</div><div class="line">    &#125; u1;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">uint32_t</span>     var_flags;</div><div class="line">        <span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></div><div class="line">        <span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></div><div class="line">        <span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></div><div class="line">        <span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></div><div class="line">        <span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></div><div class="line">        <span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></div><div class="line">    &#125; u2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>zval里首先是一个zend_value，用于存放变量的值。接下来是u1，这也是一个union，v和type_info共享4字节的内存，用于保存zval中存储的值的类型（long/double/string/object等）。接下来是一个trick。首先需要知道，在64位机器上，将struct按8字节（64bit）对齐可以获得更好的执行效率（<a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="external">Data structure alignment</a>）。在zval中，必须的两项value与type分别占据了8字节与4字节，虽然只使用了12字节，但是在编译时为了更好的性能，会按16字节对齐，这样后面就空出了4字节。为了更好的利用这部分空间，将最后4字节定义为union u2，用于在不同场合发挥功能，例如，其中的u2.next用于在HashTable里寻找下一个元素。（类似的trick在代码里随处可见，读的时候想最多的是“卧槽，太牛逼了”。）</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>终于，我们的主角登场了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Bucket &#123;</div><div class="line">    zval              val;</div><div class="line">    zend_ulong        h;   <span class="comment">/* hash value (or numeric index)   */</span></div><div class="line">    zend_string      *key; <span class="comment">/* string key or NULL for numerics */</span></div><div class="line">&#125; Bucket;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_array HashTable;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _zend_array &#123;</div><div class="line">    zend_refcounted_h gc; </div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            ZEND_ENDIAN_LOHI_4(</div><div class="line">                zend_uchar    flags,</div><div class="line">                zend_uchar    nApplyCount,</div><div class="line">                zend_uchar    nIteratorsCount,</div><div class="line">                zend_uchar    reserve)</div><div class="line">        &#125; v;</div><div class="line">        <span class="keyword">uint32_t</span> flags; </div><div class="line">    &#125; u;</div><div class="line">    <span class="keyword">uint32_t</span>          nTableMask; <span class="comment">//Table Mask, 始终等于-nTableSize</span></div><div class="line">    Bucket           *arData;     <span class="comment">//实际的数据存放位置</span></div><div class="line">    <span class="keyword">uint32_t</span>          nNumUsed;   <span class="comment">//已使用的槽位数</span></div><div class="line">    <span class="keyword">uint32_t</span>          nNumOfElements; <span class="comment">//已有的元素个数，注意这个值可能会小于nNumUsed</span></div><div class="line">    <span class="keyword">uint32_t</span>          nTableSize;  <span class="comment">//HashTable的大小，始终为2的指数（8,16,32,64...）。最小为8，最大值根据机器不同而不同</span></div><div class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</div><div class="line">    zend_long         nNextFreeElement;</div><div class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是全新的HashTable，与之前实现最大的区别是所有的Bucket作为一个数组，放在了同一块内存上（PHP5中的Bucket分别申请，并用链表连接在一起)。文章开头提到的PHP7正式版与Nikic文章中的主要区别就是这了，为了更好的理解HashTable的实现，先看看原来的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _HashTable &#123;</div><div class="line">    <span class="keyword">uint32_t</span>          nTableSize;</div><div class="line">    <span class="keyword">uint32_t</span>          nTableMask;</div><div class="line">    <span class="keyword">uint32_t</span>          nNumUsed;</div><div class="line">    <span class="keyword">uint32_t</span>          nNumOfElements;</div><div class="line">    zend_long         nNextFreeElement;</div><div class="line">    Bucket           *arData;        <span class="comment">//实际的数据</span></div><div class="line">    <span class="keyword">uint32_t</span>         *arHash;        <span class="comment">//哈希表。特定哈希值对应的数组下标。</span></div><div class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</div><div class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            ZEND_ENDIAN_LOHI_3(</div><div class="line">                zend_uchar    flags,</div><div class="line">                zend_uchar    nApplyCount,</div><div class="line">                <span class="keyword">uint16_t</span>      reserve)</div><div class="line">        &#125; v;</div><div class="line">        <span class="keyword">uint32_t</span> flags;</div><div class="line">    &#125; u;</div><div class="line">&#125; HashTable;</div></pre></td></tr></table></figure>
<p>存储中，最关键的两个是两个指针<em>arData和</em>arHash。其中，arData是Bucket的实际存储位置，在HashTable初始化的时候，会分配一块连续的能连续存放nTableSize个Bucket的内存，因此在使用时可以将其当作数组访问：arData[0], arData[1]……；arHash是一个nTableSize大小的数组，元素的key在hash之后落在0~(nTableSize-1)之间，这个数组是arData的索引，用于根据hash值迅速找到其对应的元素。</p>
<p>下面通过实例从增与查两个最基本的操作来说明具体的实现。为了描述方便，下面使用了简化的算法，实际的实现要复杂不少，但本质是一致的。</p>
<p>假定有一个空数组a = []。初始化好后，主要元素的信息如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nTableSize=<span class="number">8</span></div><div class="line">nNumUsed=<span class="number">0</span></div><div class="line">nNumOfElements=<span class="number">0</span></div><div class="line">arHash=[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1.</span>...<span class="number">-1</span>] （<span class="number">8</span>个）</div><div class="line">arData=[Bucket(NOT_INITIALIZED), Bucket(NOT_INITIALIZED)....]（<span class="number">8</span>个空位）</div></pre></td></tr></table></figure></p>
<p><strong>增（Insert）</strong></p>
<p>比如执行代码a[‘x’] = 1。首先，计算’x’的hash值，并mod nTableSize，结果记为nHashIndex，根据结果在arHash数组中对应位置查找结果，如果值为-1，表示当前hash值无冲突，将value=1写入arData[nNumUsed]位置，并将该位置记录在arHash表中；如果值不为-1，表示hash值有冲突，需要解决，详细的解决方案见下文。伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nHashIndex = hash(key) % nTableSize;</div><div class="line"><span class="keyword">int</span> nDataIndex = arHash[nHashIndex];</div><div class="line"><span class="keyword">if</span>(nDataIndex != <span class="number">-1</span>)&#123;</div><div class="line">    <span class="comment">//解决冲突</span></div><div class="line">&#125;</div><div class="line">arData[nNumUsed]=Bucket(value);</div><div class="line">arHash[nHashIndex]=nNumUsed;</div><div class="line">nNumUsed++;</div><div class="line">nNumOfElements++;</div></pre></td></tr></table></figure></p>
<p>a[‘x’] = 1执行结束后，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nTableSize=<span class="number">8</span></div><div class="line">nNumUsed=<span class="number">1</span></div><div class="line">nNumOfElements=<span class="number">1</span></div><div class="line">arHash=[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1.</span>...<span class="number">-1</span>] （一个<span class="number">0</span>与<span class="number">7</span>个<span class="number">-1</span>，假定hash(<span class="string">'x'</span>)=<span class="number">0</span>）</div><div class="line">arData=[Bucket（value = <span class="number">1</span>), Bucket(NOT_INITIALIZED)....]（<span class="number">7</span>个空位）</div></pre></td></tr></table></figure></p>
<p>如此，一次插入a[‘y’]=2; a[‘z’]=3;..<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nTableSize=<span class="number">8</span></div><div class="line">nNumUsed=<span class="number">3</span></div><div class="line">nNumOfElements=<span class="number">3</span></div><div class="line">arHash=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2.</span>...<span class="number">-1</span>] （<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>与<span class="number">5</span>个<span class="number">-1</span>，假定hash(<span class="string">'x'</span>/<span class="string">'y'</span>/<span class="string">'z'</span>)分别等于<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>）</div><div class="line">arData=[Bucket（value = <span class="number">1</span>), Bucket(value = <span class="number">2</span>), Bucket(value = <span class="number">3</span>)....]（<span class="number">5</span>个空位）</div></pre></td></tr></table></figure></p>
<p><strong>查（Find</strong></p>
<p>上面三个元素插入之后，如果要取出来，怎么操作呢？比如，要知道a[‘y’]对应的值，伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nHashIndex = hash(key) % nTableSize;</div><div class="line"><span class="keyword">int</span> nDataIndex = arHash[nHashIndex];</div><div class="line"><span class="keyword">if</span> (nDataIndex != <span class="number">-1</span>)&#123;</div><div class="line">    Bucket *target = &amp;amp;arData[nDataIndex];</div><div class="line">    <span class="keyword">if</span> (target-&amp;gt;key == key)&#123;</div><div class="line">        <span class="keyword">return</span> target;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//未找到或者遇到Hash冲突</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//NOT FOUND</span></div></pre></td></tr></table></figure></p>
<p>对应上一步的结果，可以算出nHashIndex=1，从arHash<a href="/wp-content/uploads/2015/12/basic_hashtable.svg">1</a>中取出1，因此a[‘y] = arData<a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html" target="_blank" rel="external">1</a> = Bucket(value = 2)。如此，完成了一次查找。</p>
<p><strong>Hash冲突</strong> </p>
<p>在插入时，如果遇到Hash冲突（即两个key的hash值结果一致时），上面提到的zval中空余的4字节就发挥作用了：指向同hash值的下一个元素的位置。现在来完成上面的伪代码，只需增加一行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nHashIndex = hash(key) % nTableSize;</div><div class="line"><span class="keyword">int</span> nDataIndex = arHash[nHashIndex];</div><div class="line"><span class="keyword">if</span>(nDataIndex != <span class="number">-1</span>)&#123;</div><div class="line">    value.u2.next=nDataIndex;  <span class="comment">//value是一个zval</span></div><div class="line">&#125;</div><div class="line">arData[nNumUsed]=Bucket(value); </div><div class="line">arHash[nHashIndex]=nNumUsed;</div><div class="line">nNumUsed++;</div><div class="line">nNumOfElements++;</div></pre></td></tr></table></figure></p>
<p>在查找时，当target-&gt;key与带查找的key不相同时，可以根据target-&gt;val.u2.next来找到下一个nDataIndex，上面的伪代码加上冲突解决之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nHashIndex = hash(key) % nTableSize;</div><div class="line"><span class="keyword">int</span> nDataIndex = arHash[nHashIndex];</div><div class="line"><span class="keyword">while</span> (nDataIndex != <span class="number">-1</span>)&#123;</div><div class="line">    Bucket *target = &amp;amp;arData[nDataIndex];</div><div class="line">    <span class="keyword">if</span> (target-&amp;gt;key == key)&#123;</div><div class="line">        <span class="keyword">return</span> target;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        nDataIndex = target-&amp;gt;value.u2.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//未找到</span></div></pre></td></tr></table></figure>
<p><strong>删除</strong></p>
<p>在上面的代码中，能看到HashTable里有nNumUsed和nNumOfElements，这两个值从代码里看，是同时增长，为什么需要分开记录呢？其实，这是为了让删除这个操作更容易。 新的HashTable使用了连续的内存来存放数据，如果每删除一个元素，就将其后的元素全部往前移动一个位置，在性能上是惨不忍睹的，也是完全没有必要的。实际中，找到key对应的元素后，将其标记为UNDEF，并将nNumOfElements减一就可以了，并不需要真实的删除。比如还是上面的array：$a=[‘x’ =&gt; 1, ‘y’=&gt;2, ‘z’=&gt;3], 如果执行unset($a[‘y’])，数据将会变成下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nTableSize=<span class="number">8</span></div><div class="line">nNumUsed=<span class="number">3</span></div><div class="line">nNumOfElements=<span class="number">2</span></div><div class="line">arHash=[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2.</span>...<span class="number">-1</span>] （<span class="number">0</span>,<span class="number">2</span>与<span class="number">6</span>个<span class="number">-1</span>，假定hash(<span class="string">'x'</span>/<span class="string">'y'</span>/<span class="string">'z'</span>)分别等于<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>）</div><div class="line">arData=[Bucket（value = <span class="number">1</span>), Bucket(UNDEF), Bucket(value = <span class="number">3</span>)....]（<span class="number">5</span>个空位）</div></pre></td></tr></table></figure>
<p>这样就完成了元素的删除。</p>
<p><strong>顺序</strong></p>
<p>PHP的数组是有序的，先插入的在前而后插入的靠后，比如 $a=[3,4]就和$a[4,3]不一样。在PHP5为了保持数组有序，使用了双向链表，而在PHP7中，更先进的设计可以让系统不再存储这样的链表。从上面的伪代码中可以看到，后插入的数据，总是放在了arData[nNumUsed]中，即：后插入的元素总是在arData靠后的位置，遍历时按arData的顺序进行ok了，不再需要额外的指针。</p>
<h3 id="HashTable的实现"><a href="#HashTable的实现" class="headerlink" title="HashTable的实现"></a>HashTable的实现</h3><p>上面的伪代码只是最基础的思想，在PHP7的代码实现中，使用了更有效的方式来提高效率。</p>
<p><strong>与Nikic文章中的区别</strong></p>
<p>在前面提到过，正式版的PHP7与Nikic文章中有一些区别，具体来说，正式版中移除了uint32_t *arHash指针。nTablesMask从nTableSize-1，变成了-nTableSize。 有了上面的算法，来理解这两个改变就比较容易了。 正式的PHP7中，arHash和arData共享了同一段内存。引用一段zend_types.h中的注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * HashTable Data Layout</div><div class="line"> * =====================</div><div class="line"> *</div><div class="line"> *                 +=============================+</div><div class="line"> *                 | HT_HASH(ht, ht-&gt;nTableMask) |</div><div class="line"> *                 | ...                         |</div><div class="line"> *                 | HT_HASH(ht, -1)             |</div><div class="line"> *                 +-----------------------------+</div><div class="line"> * ht-&gt;arData ---&gt; | Bucket[0]                   |</div><div class="line"> *                 | ...                         |</div><div class="line"> *                 | Bucket[ht-&gt;nTableSize-1]    |</div><div class="line"> *                 +=============================+</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>在malloc时，同时申请了arHash和arData共需的内存空间。并将arData的指针指向这段内存中间的地址，指针之前的位置放置arHash，之后的是arData。</p>
<p>nTableMask，之前值为nTableSize-1的原因是方便取模：在nTableSize为2的指数时，总有 h &amp; (nTableSize-1) = h % nTableSize ，可以用 &amp; 替代耗时的 %。例如当nTableSize = 8时，nTableSize - 1 = 7 ，表示为二进制是 000…0111，将h与这个值做 &amp; 操作，结果与 h%8 相同。</p>
<p>新的值为-nTableSize的原因也是方便取模：因为新的arHash放在了指针arData之前，所以需要取负数的模，在nTableSize为2的指数时，h | (-nTableSize) = - nTableSize + ( h % nTableSize) ，如上图，相当于是arHash的第 h% nTableSize 个位置。例如当nTableSize = 8时， -nTableSize = -8，表示为二进制为111111….1000（<a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="external">补码</a>），与h做|预算，结果是111111….1xyz = -8 + xyz，( xyz = h % 8 )，巧妙的通过|算的了下标。</p>
<p>这两个指针共享同一段内存，在初始化时可以减少一次malloc，销毁时减少一次free，同时还可以节省保存arHash指针的空间。而通过上面的算法，实现这些不需要任何额外的开销。</p>
<p><strong>Packed HashTable</strong></p>
<p>PHP7的引入了Packed HashTable，在一些特定的情况下，Packed HashTable能达到与C语言的数组相近的性能。 先回到之前zval和Bucket的定义，可以看到long和double是直接嵌入到zval中的，zval是直接嵌入到Bucket中的。这意味着每个Bucket中就有一个long或者double，也就是说，arData中，默认是有long/double的位置的。所以，当使用一个纯粹的数字数组时，比如 $a = [3, 4, 5, 6, 7], $b = [3.3, 4.3]，只需要申请一次arData的空间，然后用下标做索引，就实现了HashTable。此时访问这个数组，将不需要额外的查找，而创建时也只花费了一次malloc的时间，性能已接近C的数组。</p>
<p><strong>arHash的类型</strong></p>
<p>uint32_t *arHash。一般我们为了指向一个元素，会保存它的指针，在64位系统中，一个指针占据8个字节。而PHP7并没有将其直接指向元素，而是作为一个下标，与arData配合得到元素的位置（HashTable的最大元素个数为 32位机 0x04000000个， 64位机0x80000000个，均未超过uint32的范围)。这样做最直观的好处是省内存，同时，还有一个容易忽略的地方：zval.u2.next大小是32位。此处如果直接保存指针，zval.u2.next就无法保存下一个元素的位置了，而如果把zval.u2.next定义为64位，zval又会占据更多的空间。</p>
<p><strong>HashTable 容量</strong></p>
<p>HashTable的大小为 8 ~ 0x04000000（32位）/ 0x80000000（64位），且只允许为2的指数。定义在zend_types.h，HT_MIN_SIZE与HT_MAX_SIZE。</p>
<p>初始化时，如果指定的容量小于8，将会被强制设定为8，如果大于8，将会设置为比该值大的最小的2的指数，比如，如果设置为12，将得到一个大小为16的HashTable。如果大于HT_MAX_SIZE，触发E_ERROR， “Possible integer overflow in memory allocation”。</p>
<p>使用时，当HashTable中的元素超过nTableSize时，会将其扩大到原来容量的两倍，将原来的数据拷贝并重新计算arHash。</p>
<p><strong>Hash算法</strong></p>
<p>PHP7使用了Daniel J. Bernstein的DJBX33A算法，核心思想是 hash (i) = hash (i - 1) * 33 + str[i]，详细的实现在zend_string.c中。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.xiezj.net/2015/12/09/PHP7之HashTable/" data-id="ciyaiqqk6000070nq0wb1j7h9" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-PHP7源码的编译与调试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/PHP7源码的编译与调试/" class="article-date">
  <time datetime="2015-12-09T11:56:20.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/PHP7源码的编译与调试/">PHP7源码的编译与调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PHP7源码的编译和调试很方便，此处简要介绍一下在Ubuntu下的调试方法（使用其他系统的话可以用虚拟机启一台Ubuntu）</p>
<ol>
<li>带界面的Ubuntu。首选官方Ubuntu Desktop，推荐LTS版本。如果用虚拟机性能不足的话，可以使用XUbuntu 。</li>
<li>集成gdb界面的IDE。直接命令行gdb调试太辛苦，效率也不高，建议使用IDE调试。这里推荐使用eclipse cdt和QtCreator。</li>
<li><p>PHP7代码。从官网<a href="http://php.net/" target="_blank" rel="external">http://php.net/</a>下载打包好的源码，解压后进入目录，运行</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --enable-debug --prefix=/home/php/usr</div></pre></td></tr></table></figure>
<p> –enable-debug表示开启调试，编译时才会带上调试符号，要调试的话一定要带上。prefix指安装的目录，为了避免不小心装到系统目录里，建议自行选择一个目录。然后就是 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make</div></pre></td></tr></table></figure>
<p> 了。编译好后的可执行文件在sapi下，分为不同的版本cli、fpm、cgi等。调试简单脚本时，最方便的是sapi/cli/php，即命令行的php。</p>
</li>
<li><p>配置IDE </p>
<ul>
<li>eclipse</li>
</ul>
<ol>
<li>记得选择for C/C++ developer的eclipse（集成CDT才能调试）。任选一个workspace之后，点击上方的File–Import，如下图选择Existing code as Autotools project（选as Makefile project也行）<img src="/2015/12/09/PHP7源码的编译与调试/JBSER5YCL8QZVVGAU6.png" alt="basic_hashtable" title="basic_hashtable">
<ol>
<li>然后选择php源码的目录，一直下一步到完成，eclipse会自动索引整个代码，然后就能方便的看代码了。一般到这一步，eclipse会提示有些文件的代码有错，不用管它，因为有些定义没找到，只要上一步编译正常就ok，不影响调试。</li>
<li>配制debug。在上方选择Run/Debug Configurations… 新建一个C/C++ Application的调试配置。选择刚才编译好的php可执行文件，并在Arguments里配上待调试的php文件位置 
<img src="/2015/12/09/PHP7源码的编译与调试/ISQ489O32RBF_Y633VU.png" alt="basic_hashtable" title="basic_hashtable"></li>
<li>再点击右下角的Debug，大功告成！默认情况下eclipse会停在main函数的入口处，然后就可以愉快的打断点调试了。在这个地方eclipse可能会提示代码有错误，是否继续调试？不用管它，强制开始就好。</li>
</ol>
</li>
</ol>
<ul>
<li>Qt Creator<ol>
<li>使用方法和eclipse类似，安装之后选File/New File or Project/Import Project/Import Existing Project，依次选目录，加进去即可。 <img src="/2015/12/09/PHP7源码的编译与调试/qt.png" alt="basic_hashtable" title="basic_hashtable"></li>
<li>待索引好后，依次点击上方的Debug/Start Debugging/Start Debugging Without Deployment， 然后和依次填写要调试的可执行文件和arguments（和eclipse差不多），然后就大功告成了！如果Qt Creator没有默认停住，在代码里打个断点重新开始就行了。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>个人觉得eclipse使用更方便，但是在使用调试的时候，有些变量打不出，而使用Qt Creator就正常。貌似是eclipse的一个bug，结合两个IDE使用就ok了。 其他的调试工具配置方法都类似：先自己编译源码（记得加–enable-debug），编译好为调试工具设置可执行文件、代码目录、arguments即可。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.xiezj.net/2015/12/09/PHP7源码的编译与调试/" data-id="ciyaiqqka000170nq53x9t3tt" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
</article>


    
  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Zongjun Xie<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>



<script src="/js/jquery.scrollUp.min.js"></script>
<script src="/js/jquery.transform.js"></script>
<script src="/js/menu.js"></script>

<script src="/js/script.js"></script>
<script src="/js/scrollUp.js"></script>

  </div>
</body>
</html>